From: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
Date: Thu, 6 Feb 2020 16:50:24 +0100
Subject: Add support for rumble and leds

Rumble support is available to user-space via the standard rumble input
interface.

Leds are controlled by led class devices (<device name>:amber:<number>)
for the amber leds and (<device name>:white:fuji>) for the atari logo
led.

For the atari logo led the led can be switched between firmware and host
control using the extra firmware_control sysfs file in the led class
device. Hw supported led blinking is also support and can be triggered
by setting the "trigger" sysfs file to the timer trigger (valid delays
are 500 and 200ms on/off).

All other leds can be switched as a group via the "leds_firmware_control"
sysfs file on the hid device.

Signed-off-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
---
 drivers/hid/hid-atari.c | 481 +++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 480 insertions(+), 1 deletion(-)

diff --git a/drivers/hid/hid-atari.c b/drivers/hid/hid-atari.c
index acda587..fb1bcc2 100644
--- a/drivers/hid/hid-atari.c
+++ b/drivers/hid/hid-atari.c
@@ -10,6 +10,74 @@
 #define map_abs(c)	hid_map_usage(hi, usage, bit, max, EV_ABS, (c))
 #define map_rel(c)	hid_map_usage(hi, usage, bit, max, EV_REL, (c))
 
+#define ATARI_FF_REPORT 1
+#define ATARI_LED_REPORT 2
+
+
+#define FUJI_LED_AUTO		0x0
+#define FUJI_LED_ON		0x1
+#define FUJI_LED_OFF		0x2
+#define FUJI_LED_SLOW_BLINK	0x3
+#define FUJI_LED_FAST_BLINK	0x4
+
+#define LED_FLAG_GLOBAL_BRIGHTNESS	BIT(0)
+#define LED_FLAG_LEDS			BIT(1)
+#define LED_FLAG_FUJI_LED		BIT(2)
+#define LED_FLAG_FIRMWARE_CONTROL	BIT(7)
+
+/* leds controlled by the host */
+#define LEDS_FIRMWARE_HOST    0
+/* leds controlled by the firmware */
+#define LEDS_FIRMWARE_ENABLE  1
+#define LEDS_FIRMWARE_ENABLED 2
+
+
+
+#define CLASSIC_LEDS 24
+#define MODERN_LEDS 4
+
+struct led_report {
+	__u8 report_id;
+	__u8 flags;
+	__u8 global_brightness;
+	__u8 system_leds;
+	__u8 data[CLASSIC_LEDS];
+} __packed;
+
+struct ff_report {
+	__u8 report_id;
+	__u8 flags;
+	__u8 strong_strength;
+	__u8 strong_on_period;
+	__u8 strong_off_period;
+	__u8 strong_repeat;
+	__u8 weak_strength;
+	__u8 weak_on_period;
+	__u8 weak_off_period;
+	__u8 weak_repeat;
+} __packed;
+
+struct atari_data {
+	struct hid_device *hdev;
+	struct mutex lock;
+
+	struct delayed_work led_worker;
+	bool led_fast_update_scheduled;
+	void *led_report_dma;
+	struct led_classdev fuji_cled;
+	struct led_classdev cleds[CLASSIC_LEDS];
+
+	/* led brightnesses */
+	u8 fuji_led;
+	u8 leds_firmware_control;
+	u8 leds[CLASSIC_LEDS];
+
+	struct work_struct ff_worker;
+	void *ff_report_dma;
+	u8 strong_ff;
+	u8 weak_ff;
+};
+
 static int atari_map_classic(struct hid_device *hdev, struct hid_input *hi,
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
@@ -163,9 +231,384 @@ static int atari_raw_event(struct hid_device *hdev, struct hid_report *report,
 	return 0;
 }
 
+static void atari_led_worker(struct work_struct *work)
+{
+	struct atari_data *ata = container_of(work,
+					      struct atari_data,
+					      led_worker.work);
+	struct led_report *r = ata->led_report_dma;
+	int ret;
+	int i;
+
+	mutex_lock(&ata->lock);
+	ata->led_fast_update_scheduled = false;
+	r->report_id = ATARI_LED_REPORT;
+	r->flags = LED_FLAG_FUJI_LED;
+	r->system_leds = ata->fuji_led;
+
+	if (!ata->leds_firmware_control) {
+		r->flags |= LED_FLAG_LEDS;
+		for (i = 0; i < CLASSIC_LEDS; i++) {
+			r->data[i] = ata->leds[i];
+		}
+	} else if (ata->leds_firmware_control ==  LEDS_FIRMWARE_ENABLE) {
+		r->flags |= LED_FLAG_FIRMWARE_CONTROL;
+		ata->leds_firmware_control = LEDS_FIRMWARE_ENABLED;
+	}
+	mutex_unlock(&ata->lock);
+
+	ret = hid_hw_output_report (ata->hdev, (__u8 *)r, sizeof(*r));
+	if (ret < 0)
+		hid_warn(ata->hdev, "Failed to send led report...: %d", ret);
+
+	mutex_lock(&ata->lock);
+	/* Workaround the firmware taking back control */
+	if (ata->fuji_led != FUJI_LED_AUTO || !ata->leds_firmware_control)
+		queue_delayed_work (system_wq, &ata->led_worker,
+				    msecs_to_jiffies (2000));
+	mutex_unlock(&ata->lock);
+}
+
+static void atari_schedule_led_update (struct atari_data *ata)
+{
+	mutex_lock(&ata->lock);
+	if (!ata->led_fast_update_scheduled) {
+		mod_delayed_work (system_wq, &ata->led_worker, msecs_to_jiffies (2));
+		ata->led_fast_update_scheduled = true;
+	}
+	mutex_unlock(&ata->lock);
+}
+
+static void atari_fuji_led_set(struct led_classdev *led_dev,
+			       enum led_brightness value)
+{
+	struct device *dev = led_dev->dev->parent;
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+
+	mutex_lock(&ata->lock);
+	ata->fuji_led = value > 0 ? FUJI_LED_ON : FUJI_LED_OFF;
+	mutex_unlock(&ata->lock);
+
+	atari_schedule_led_update (ata);
+}
+
+static int atari_fuji_led_set_blink(struct led_classdev *led_dev,
+				     unsigned long *delay_on,
+				     unsigned long *delay_off)
+{
+	struct device *dev = led_dev->dev->parent;
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+
+	mutex_lock(&ata->lock);
+	if (!*delay_on || *delay_on > 350) {
+		*delay_on = 500;
+		*delay_off = 500;
+		ata->fuji_led = FUJI_LED_SLOW_BLINK;
+	} else {
+		*delay_on = 200;
+		*delay_off = 200;
+		ata->fuji_led = FUJI_LED_FAST_BLINK;
+	}
+	mutex_unlock(&ata->lock);
+
+	atari_schedule_led_update (ata);
+
+	return 0;
+}
+
+static void atari_led_set(struct led_classdev *led_dev,
+			  enum led_brightness value)
+{
+	struct device *dev = led_dev->dev->parent;
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+	int i;
+
+	for (i = 0 ; i < CLASSIC_LEDS ; i++) {
+		if (led_dev == &ata->cleds[i])
+			break;
+	}
+	BUG_ON(i >= CLASSIC_LEDS);
+
+	mutex_lock(&ata->lock);
+	ata->leds_firmware_control = false;
+	ata->leds[i] = value & 0xff;
+	mutex_unlock(&ata->lock);
+
+	atari_schedule_led_update (ata);
+}
+
+static ssize_t firmware_control_show(struct device *led_dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct device *dev = led_dev->parent;
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+	unsigned int v;
+
+	mutex_lock(&ata->lock);
+	v = ata->fuji_led == FUJI_LED_AUTO;
+	mutex_unlock(&ata->lock);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", v);
+}
+
+static ssize_t firmware_control_store(struct device *led_dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t count)
+{
+	struct device *dev = led_dev->parent;
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+	int err;
+	int control;
+
+	err = kstrtouint (buf, 10, &control);
+	if (err)
+		return err;
+	
+	if (control != 0 && control != 1)
+		return -EINVAL;
+	
+	mutex_lock(&ata->lock);
+	ata->fuji_led = control ? FUJI_LED_AUTO : FUJI_LED_OFF;
+	mutex_unlock(&ata->lock);
+
+	atari_schedule_led_update (ata);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(firmware_control);
+static struct attribute *atari_fuji_led_attrs[] = {
+	&dev_attr_firmware_control.attr,
+	NULL
+};
+
+static const struct attribute_group atari_fuji_led_group = {
+	.attrs = atari_fuji_led_attrs,
+};
+
+static const struct attribute_group *atari_fuji_led_groups[] = {
+	&atari_fuji_led_group,
+	NULL
+};
+
+static int atari_register_fuji_led (struct atari_data *ata)
+{
+	char *name;
+	int ret = 0;
+	struct device *dev = &ata->hdev->dev;
+	size_t name_sz = strlen(dev_name(dev)) + 16;
+	struct led_classdev *led = &ata->fuji_cled;
+
+
+	name = devm_kzalloc (dev, name_sz, GFP_KERNEL);
+	if (name == NULL)
+		return -ENOMEM;
+
+	snprintf(name, name_sz, "%s:white:fuji",  dev_name(dev));
+	led->name = name;
+	led->brightness = 0;
+	led->max_brightness = 1;
+	led->brightness_set = atari_fuji_led_set;
+	led->blink_set = atari_fuji_led_set_blink;
+	led->groups = atari_fuji_led_groups;
+
+	ret = devm_led_classdev_register(dev, led);
+	return ret;
+}
+
+
+static int atari_register_main_led (struct atari_data *ata, int index)
+{
+	char *name;
+	int ret = 0;
+	struct device *dev = &ata->hdev->dev;
+	size_t name_sz = strlen(dev_name(dev)) + 16;
+	struct led_classdev *led = &ata->cleds[index];
+
+	name = devm_kzalloc (dev, name_sz, GFP_KERNEL);
+	if (name == NULL)
+		return -ENOMEM;
+
+	snprintf(name, name_sz, "%s:amber:%02d",  dev_name(dev), index);
+	led->name = name;
+	led->brightness = 0;
+	led->max_brightness = 0xff;
+	led->brightness_set = atari_led_set;
+
+	ret = devm_led_classdev_register(dev, led);
+	return ret;
+}
+
+static ssize_t leds_firmware_control_show(struct device *dev,
+			 struct device_attribute *attr,
+			 char *buf)
+{
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+	bool v;
+
+	mutex_lock(&ata->lock);
+	v = ata->leds_firmware_control > 0;
+	mutex_unlock(&ata->lock);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", v);
+}
+
+static ssize_t leds_firmware_control_store(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf,
+			 size_t count)
+{
+	struct atari_data *ata = hid_get_drvdata(to_hid_device(dev));
+	int err;
+	int control;
+
+	err = kstrtouint (buf, 10, &control);
+	if (err)
+		return err;
+	
+	if (control != 0 && control != 1)
+		return -EINVAL;
+	
+	mutex_lock(&ata->lock);
+	ata->leds_firmware_control = control;
+	if (!control) {
+		memset(ata->leds, 0, sizeof(ata->leds));
+	}
+	mutex_unlock(&ata->lock);
+
+	atari_schedule_led_update (ata);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(leds_firmware_control);
+static struct attribute *atari_leds_attrs[] = {
+	&dev_attr_leds_firmware_control.attr,
+	NULL
+};
+
+static const struct attribute_group atari_leds_group = {
+	.attrs = atari_leds_attrs,
+};
+
+static int atari_register_leds (struct atari_data *ata) {
+	int ret = 0;
+	int i = 0;
+	int nleds = 4;
+
+	INIT_DELAYED_WORK(&ata->led_worker, atari_led_worker);
+	if (ata->hdev->product == USB_DEVICE_ID_ATARI_CLASSIC)
+		nleds = 24;
+
+	ret = atari_register_fuji_led(ata);
+	if (ret)
+		return ret;
+
+	for (i = 0 ; i < nleds ; i++) {
+		ret = atari_register_main_led (ata, i);
+		if (ret != 0)
+			break;
+	}
+
+	/* Default to all leds under firmware control */
+	ata->leds_firmware_control = LEDS_FIRMWARE_ENABLE;
+	ata->fuji_led = FUJI_LED_AUTO;
+
+	return ret;
+}
+
+static void atari_ff_worker(struct work_struct *work)
+{
+	struct atari_data *ata = container_of(work, struct atari_data, ff_worker);
+	struct hid_device *hdev = ata->hdev;
+	struct ff_report *r = ata->ff_report_dma;
+	int ret;
+
+	memset(r, 0, sizeof(*r));
+
+	mutex_lock (&ata->lock);
+	r->report_id = ATARI_FF_REPORT;
+	r->flags = BIT(0) | BIT(1);
+	r->strong_strength = ata->strong_ff;
+	r->weak_strength = ata->weak_ff;
+
+	r->strong_on_period = U8_MAX;
+	r->weak_on_period = U8_MAX;
+
+	r->strong_repeat = 0;
+	r->weak_repeat = 0;
+
+	r->strong_off_period = 0;
+	r->weak_off_period = 0;
+	mutex_unlock (&ata->lock);
+
+	ret = hid_hw_output_report(hdev, (__u8 *)r, sizeof(*r));
+	if (ret < 0)
+		hid_warn(hdev, "failed to send FF report\n");
+}
+
+static int atari_play_effect(struct input_dev *dev, void *data,
+			  struct ff_effect *effect)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct atari_data *ata = hid_get_drvdata(hid);
+
+	if (effect->type != FF_RUMBLE)
+		return 0;
+
+	/* scale back to 8 bits */
+	mutex_lock (&ata->lock);
+	ata->strong_ff = effect->u.rumble.strong_magnitude >> 8;
+	ata->weak_ff = effect->u.rumble.weak_magnitude >> 8;
+	mutex_unlock (&ata->lock);
+
+	schedule_work(&ata->ff_worker);
+	return 0;
+}
+
+static int atari_init_ff(struct atari_data *ata)
+{
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
+
+	if (list_empty(&ata->hdev->inputs)) {
+		hid_err(ata->hdev, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(ata->hdev->inputs.next, struct hid_input, list);
+	input_dev = hidinput->input;
+
+	INIT_WORK(&ata->ff_worker, atari_ff_worker);
+	ata->ff_report_dma = devm_kzalloc(&ata->hdev->dev,
+					 sizeof(struct ff_report),
+					 GFP_KERNEL);
+	if (ata->ff_report_dma == NULL)
+		return -ENOMEM;
+
+	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+	return input_ff_create_memless(input_dev, NULL, atari_play_effect);
+}
+
 static int atari_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
 	int ret;
+	struct atari_data *ata;
+
+	ata = devm_kzalloc(&hdev->dev, sizeof(*ata), GFP_KERNEL);
+	if (ata == NULL)
+		return -ENOMEM;
+	
+	ata->hdev = hdev;
+	mutex_init(&ata->lock);
+	ata->led_report_dma = devm_kzalloc(&hdev->dev,
+					   sizeof(struct led_report),
+					   GFP_KERNEL);
+	if (ata->led_report_dma == NULL)
+		return -ENOMEM;
+
+	hid_set_drvdata(hdev, ata);
 
 	ret = hid_parse(hdev);
 	if (ret) {
@@ -179,11 +622,46 @@ static int atari_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		return ret;
 	}
 
-	return 0;
+	ret = atari_register_leds (ata);
+	if (ret) {
+		hid_err(hdev, "failed to register leds\n");
+		return ret;
+	}
+
+	ret = atari_init_ff (ata);
+	if (ret) {
+		hid_err(hdev, "failed to register ff\n");
+		return ret;
+	}
+
+	ret = sysfs_create_group (&hdev->dev.kobj, &atari_leds_group);
+	if (ret < 0) {
+		hid_err(hdev, "error creating sysfs attrs\n");
+		return ret;
+	}
+
+	/* Synchronize the leds state */
+	atari_schedule_led_update (ata);
+	return ret;
 }
 
 static void atari_remove(struct hid_device *hdev)
 {
+	struct atari_data *ata = hid_get_drvdata(hdev);
+	int i;
+
+	cancel_work_sync(&ata->ff_worker);
+
+	sysfs_remove_group (&ata->hdev->dev.kobj, &atari_leds_group);
+
+	devm_led_classdev_unregister(&hdev->dev, &ata->fuji_cled);
+	for (i = 0 ; i < CLASSIC_LEDS; i++) {
+		if (ata->cleds[i].name == NULL)
+			break;
+		devm_led_classdev_unregister(&hdev->dev, &ata->cleds[i]);
+	}
+	cancel_delayed_work_sync(&ata->led_worker);
+
 	hid_hw_stop(hdev);
 }
 
@@ -204,6 +682,7 @@ static struct hid_driver atari_driver = {
 	.probe		= atari_probe,
 	.remove		= atari_remove,
 };
+
 module_hid_driver(atari_driver);
 
 MODULE_AUTHOR("Sjoerd Simons");
