From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Fri, 29 Jan 2021 13:09:59 +0100
Subject: [PATCH 19/19] firewire: ohci: Use tasklet_disable_in_atomic() in the
 two atomic user
Origin: https://www.kernel.org/pub/linux/kernel/projects/rt/5.10/older/patches-5.10.17-rt32.tar.xz

ohci_cancel_packet() can be invoked from ar_context_tasklet(). It
will cancel a different tasklet than it is running.

ohci_flush_iso_completions() can be invoked from other driver either
from a tasklet or from a workqueue with disabled preemption.
The function irq_target_callback() make it appear to be invoked from
IRQ-context. The `sc' callback it assigns can be tracked back to the
flush_iso_completions() function. This is called from preemptible
context (ohci_allocate_iso_context()) and ohci_flush_iso_completions().

The invocation from at_context_flush() is always preemptible.

Use tasklet_disable_in_atomic() for the two invocations from atomic
context.

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 drivers/firewire/ohci.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/drivers/firewire/ohci.c
+++ b/drivers/firewire/ohci.c
@@ -2545,7 +2545,7 @@ static int ohci_cancel_packet(struct fw_
 	struct driver_data *driver_data = packet->driver_data;
 	int ret = -ENOENT;
 
-	tasklet_disable(&ctx->tasklet);
+	tasklet_disable_in_atomic(&ctx->tasklet);
 
 	if (packet->ack != 0)
 		goto out;
@@ -3465,7 +3465,7 @@ static int ohci_flush_iso_completions(st
 	struct iso_context *ctx = container_of(base, struct iso_context, base);
 	int ret = 0;
 
-	tasklet_disable(&ctx->context.tasklet);
+	tasklet_disable_in_atomic(&ctx->context.tasklet);
 
 	if (!test_and_set_bit_lock(0, &ctx->flushing_completions)) {
 		context_tasklet((unsigned long)&ctx->context);
